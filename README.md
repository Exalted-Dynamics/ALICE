#ALICE
<i></i>
---
* <b>Advance</b> <i> - Growth. Moving forward. </i>
* <b>Logical</b> <i> - Reasonable. Clear. Concise.</i>
* <b>Inception</b> <i>- Beginning, Birth, Origination</i>
* <b>Creation</b> <i> - The world and all the things in it.</i>
* <b>Engine</b> <i> - Force. Motion. </i>
---
##Introduction

Boilerplate code has become a part of our lives. It has to be there, we have to tolerate it. If it's not there or if we do something to upset it's nature, then we get yelled at for it. Well that's not fair. It's just too much to mentally keep up with. 

We've got the languages' boilerplate, the company's boilerplate, the annoying associates with ocd motivated demands boilerplate, you name it. It's probably there. Point is, it's just too much inflation caused by boilerplate syntax.

ALICE is here to help you advance your creation logically, by giving you the vehicle to alter the initial inception of your project.

>All this tech jive...I'll see you at the getting started section if you don't want to be bored to death.
> 
##Advance
We deserve a platform that allows us to move forward, don't we? If you're here reading this readme chances are you have probably gotten tired of writing the same boring chunks of code over and over. In the project you'll find an example of a java maven project created with minimum input from you.

Wait, minimum input?

>Minimum input...That's what it says!

Most of the development on the backend is cookie cutter. Frontend code, so redundant you fret to exhaustion having to write this code. I mean come on, a lot of them ship with cmd line interfaces that assist in generating boilerplate code, I imagine you can probably alter this somehow, but probably wouldn't be a good idea. 

You may even find yourself just copying and pasting code. A chunk here, a chunk there, a chunk every...

>*****yawning***
>They...get...the...point.

ALICE's focus is finding those chunks and providing a means to access them. With this access you have the ability to create templates of code which can be used to build out as far as you can imagine. In the sample project you will see ALICE build applications from what appears to be a SQL file to several microservices which make up an API as a whole. Documentation is generated for the new API, as well as the option to generate boilerplate code necessary to interface with the API. We're not just talking some generated stubs which teach you to interface with the api in some third party app. We're talking full projects.

ALICE acts a pseudo-compiler for your project which builds/generates code for a secondary compiler, of your choice. In the example we generate a java maven project with databases access to a mysql database using spring boot. 

>Did you hear that? Pseudo-...compiler...
> Tell them what a pseudo compiler is...

It's an application that mimics the actions of a compiler, It interprets the code based on how you tell it to interpret it, allowing you to developer shortcuts, informal syntax. 

>Slang! Just say it man!
>Look, you can call whatever you want, but it's Slang. You can write your own syntax 
> 
> So, If I didn't know the way Java's implemented it's naming convention for the syntax, I can take each of their syntax entries and alias them to my own, even customizing what they do. You have full control over your language.
> 
> It's got all the industry standard's jive in it, but you can alter it, as well as rename it! Plus you can have a look at what other coders like yourself have done and possibly incorporate that into your package.

>Now again, I'm gon' tell you ALICE can work like nothing else, but if you're not specific in what you want done. There's no telling what ALICE will do.

>Peep a few scenarios you'll see what I mean. Maybe you're smart enough to figure out how to address that. We'll get to all of that in a sec, when I talk about the 'do's and dont's' of forking with ALICE.

####Scenario I
Let's say that you're a software developer, and you are approached with the task of creating a project similar in nature, but a different database type is required, oh, and it's due by tomorrow. Pressed for time, your quickest option is copying a template and modifying only the portions you need.

####Scenario II
Let's say you're in the stage of maintenance for your development life cycle. We've all been there when it finally hit's that sweet spot where defects kind of trickle in, and it's mainly because of some feature you're missing on the backend. 

Theodor has a few bones to pick with how certain elements are logged throughout the project, which he believes is the reason the team is not getting enough information to understand root cause for several defects. He brings it to the team, and they agree it should be a new standard going forward.

Now he's faced with several tasks to accomplish:
- He must update the codebase logging to reflect the changes.
- He must update the documentation on the new standards.
- He has to test the project or at least validate the automated tests. 
- Etc, etc, etc...

It's just too bad this standard couldn't have been applied from the beginning. Unfortunately, we have yet to obtain the ability to time travel.

>Yuh, yuh, yuh...Hurry up man, get to the point.

If you're thinking pseudo-interpreter, you're with me still. Remember the interpreter is non-binary source, so you are allowed edit it further, as an interpreter should. In your own fork, you have the flexibility to modify the language of the pseudo-interpreter. How much is up to you. 

>What he's trying to say, you do have the ability to time travel. 

You see, once you have created a generator template you initially created a snapshot. That spot is forever marked in time. If you're like Theodor, constantly working on large projects, the boilerplate code is going to be overwhelming when you consider updating it. You know the amount of work coming. If only we can travel back in time.

Well you see, technically we can, with the snapshot. We modify the code for the interpreter to generate the code. So, in theory.

Theodor can create a new branch, clone the previous template, the snapshot, to the new template. He would then proceed to update the logging in the new template as if it was originally specified at the start of the project. He would build the project with no changes made to ALICE's work order, ambitions or application settings unless required.

>*****rolling eyes***

I introduce you a pseudo-language!

>Oh brother. Man will you hurry up!

Ok, so finally to the cool part. Technically there's a new language for you to learn, but technically it's not a new language, yet. The pseudo-language is an extension of SQL in terms of syntax. The rest is up to you.

>Dig it, Welcome, I see you're here because you're looking for a way to really make your code work for you. You're tired of developing the same old tasks and daily routines. I know I am. So anyway, I got what you need. I'd like you to meet ALICE. You can make ALICE generate most of the framework for your frontend projects. Now, I'm going to loan ALICE to you so you can get a feel for how it feels to be the comforts of good workers. As stated, it's totally up to you! It's pimping baby! Happy Coding! ;)

>ALICE, is a project developed with intentions of removing the guess work out of the process of creating a new project from start to finish. Stencil scripted automation. ALICE's reputation depends on inflating, things. No, seriously, whose to say what those things are. It's totally up to you. Just follow the guidelines, and you'll be on your way of creating API's with their respective documentation.

##Advanced

##Inception
##Creation

##Engine

ALICE is an engine fueled by languages. The more languages supported the more complex of an environment ALICE is capable of creating. This is what adds that special glow around ALICE. How many times have you created a project with a tech stack and about halfway through the project you finally stop being stubborn and admit that some  languages chosen to do their respective jobs was not the most appropriate for that particular instance, and of course you can't change it this late. 

ALICE allows you to do that with ease as long as you have your original snapshot and settings. You can alter the course of your project in any direction.

>What? No AI? I'm surprised you didn't code some type of machine learning software to prevent them from making those mistakes.

It's best you see the documentation.

##Getting Started
1. Create your application.properties file. 
   
Configure all your database goodies and whatnot.
   
2. Edit the config ambitions.conf

>Now moving right along, you're going to want to get command, or she'll take off on you. It's a bitch to fix, so I suggest you get started by introducing yourself and lay your game down immediately. That way she'll know you ain't for no bullshit. 

>I suggest you help ALICE to understand what her ambitions are while I'm absent and give me a holla back, ya dig?

...

>Cool, glad to see you made it back in one piece. ALICE can be a bit of a nag but once y'all come to an understanding everything is everything baby.

>So next is...
3. Add your SQL file. (Work Order)
   
>Note if you want to help the file parser out a bit, Just include the CREATE statements. If you're looking for support with the other statements, see the advanced documentation on create your own generator template. 
   
>Finally, one last thing, and I can get out of here.

4. Run the putAliceToWork.php script

```
php putAliceToWork.php
```



##Usage Examples

##Notes
Alright, I'm out, don't do nothing that I wouldn't do!

## Definitions

####Work Order
ALICE accepts work orders. Work orders are essentially SQL statements. Again the concept is minimum input. So at this point, we have a psuedo-compiler and pseudo-interpreter. What else is required. Drumroll, please?!

##